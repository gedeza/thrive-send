// TypeScript types for Recommendation Network system

export interface Newsletter {
  id: string;
  title: string;
  description?: string;
  clientId: string;
  organizationId: string;
  subscriberCount: number;
  averageOpenRate: number;
  averageClickRate: number;
  categories: string[];
  targetAudience: Record<string, any>;
  isActiveForRecommendations: boolean;
  recommendationWeight: number;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  client?: {
    id: string;
    name: string;
    type: string;
  };
  organization?: {
    id: string;
    name: string;
  };
  outgoingRecommendations?: NewsletterRecommendation[];
  incomingRecommendations?: NewsletterRecommendation[];
  fromMatches?: RecommendationMatch[];
  toMatches?: RecommendationMatch[];
}

export interface NewsletterRecommendation {
  id: string;
  fromNewsletterId: string;
  toNewsletterId: string;
  status: RecommendationStatus;
  type: RecommendationType;
  priority: number; // 1-10
  startDate: string;
  endDate?: string;
  targetAudienceOverlap: number;
  estimatedReach: number;
  metadata: Record<string, any>;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  fromNewsletter?: Newsletter;
  toNewsletter?: Newsletter;
  performance?: RecommendationPerformance[];
}

export interface RecommendationPerformance {
  id: string;
  recommendationId: string;
  period: PerformancePeriod;
  periodStart: string;
  periodEnd: string;
  impressions: number;
  clicks: number;
  conversions: number; // New subscribers
  revenue: number;
  ctr: number; // Click-through rate
  conversionRate: number;
  costPerConversion: number;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  recommendation?: NewsletterRecommendation;
}

export interface RecommendationSettings {
  id: string;
  organizationId: string;
  isNetworkActive: boolean;
  autoAcceptRecommendations: boolean;
  maxRecommendationsPerNewsletter: number;
  minAudienceOverlap: number;
  preferredCategories: string[];
  excludedOrganizations: string[];
  revSharePercentage: number;
  qualityThreshold: number; // 1-5 scale
  settings: Record<string, any>;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  organization?: {
    id: string;
    name: string;
  };
}

export interface RecommendationMatch {
  id: string;
  fromNewsletterId: string;
  toNewsletterId: string;
  matchScore: number; // 0-100
  categoryAlignment: number;
  audienceCompatibility: number;
  performanceHistory: number;
  geographicAlignment: number;
  seasonalRelevance: number;
  competitionLevel: number;
  isAutoGenerated: boolean;
  lastCalculated: string;
  metadata: Record<string, any>;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  fromNewsletter?: Newsletter;
  toNewsletter?: Newsletter;
}

// Enums
export enum RecommendationStatus {
  ACTIVE = 'ACTIVE',
  PAUSED = 'PAUSED',
  ENDED = 'ENDED',
  PENDING_APPROVAL = 'PENDING_APPROVAL',
  REJECTED = 'REJECTED'
}

export enum RecommendationType {
  MUTUAL = 'MUTUAL',
  ONE_WAY = 'ONE_WAY',
  SPONSORED = 'SPONSORED'
}

export enum PerformancePeriod {
  DAILY = 'DAILY',
  WEEKLY = 'WEEKLY',
  MONTHLY = 'MONTHLY',
  QUARTERLY = 'QUARTERLY'
}

// API Request/Response types
export interface CreateNewsletterRequest {
  title: string;
  description?: string;
  clientId: string;
  categories: string[];
  targetAudience?: Record<string, any>;
  subscriberCount?: number;
}

export interface CreateRecommendationRequest {
  fromNewsletterId: string;
  toNewsletterId: string;
  type: RecommendationType;
  priority?: number;
  endDate?: string;
  metadata?: Record<string, any>;
}

export interface RecommendationNetworkOverview {
  newsletter_id: string;
  title: string;
  organizationId: string;
  subscriberCount: number;
  averageOpenRate: number;
  outgoing_recommendations: number;
  incoming_recommendations: number;
  avg_conversion_rate: number;
  total_conversions: number;
}

export interface TopPerformingRecommendation {
  id: string;
  from_newsletter: string;
  to_newsletter: string;
  from_org: string;
  to_org: string;
  avg_conversion_rate: number;
  total_conversions: number;
  total_revenue: number;
  avg_ctr: number;
}

// Component Props interfaces
export interface RecommendationManagerProps {
  organizationId: string;
  mode?: 'full' | 'embedded';
  showMetrics?: boolean;
  showRecommendations?: boolean;
  showMatches?: boolean;
  maxRecommendations?: number;
  onRecommendationCreate?: (recommendation: NewsletterRecommendation) => void;
  onRecommendationUpdate?: (recommendation: NewsletterRecommendation) => void;
  className?: string;
}

export interface RecommendationNetworkDashboardProps {
  organizationId: string;
  newsletters: Newsletter[];
  recommendations: NewsletterRecommendation[];
  settings: RecommendationSettings;
  onSettingsUpdate: (settings: Partial<RecommendationSettings>) => void;
  className?: string;
}

// Analytics and Metrics types
export interface RecommendationNetworkMetrics {
  totalNewsletters: number;
  activeRecommendations: number;
  totalConversions: number;
  averageConversionRate: number;
  totalRevenue: number;
  networkReach: number;
  topPerformingRecommendations: TopPerformingRecommendation[];
  monthlyGrowth: number;
  qualityScore: number;
}

export interface RecommendationMatchingCriteria {
  categoryWeight: number;
  audienceCompatibilityWeight: number;
  performanceHistoryWeight: number;
  geographicWeight: number;
  seasonalWeight: number;
  competitionWeight: number;
  minMatchScore: number;
  maxSuggestions: number;
}

// Matching algorithm interfaces
export interface MatchingAlgorithmInput {
  sourceNewsletter: Newsletter;
  candidateNewsletters: Newsletter[];
  criteria: RecommendationMatchingCriteria;
  excludeOrganizations?: string[];
  includeCategories?: string[];
}

export interface MatchingAlgorithmResult {
  matches: RecommendationMatch[];
  totalCandidates: number;
  processingTimeMs: number;
  algorithmVersion: string;
}

// Filter and search types
export interface RecommendationFilters {
  status?: RecommendationStatus[];
  type?: RecommendationType[];
  categories?: string[];
  minConversionRate?: number;
  maxConversionRate?: number;
  dateRange?: {
    start: string;
    end: string;
  };
  organizationIds?: string[];
  search?: string;
}

export interface NewsletterFilters {
  isActive?: boolean;
  categories?: string[];
  minSubscribers?: number;
  maxSubscribers?: number;
  minOpenRate?: number;
  organizationIds?: string[];
  search?: string;
}

// Pagination and sorting
export interface PaginationParams {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
  meta?: Record<string, any>;
}